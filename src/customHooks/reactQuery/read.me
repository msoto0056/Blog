
**************
React Query hooks 
npm i react-query axios react-loader-spinner
usage:
**
in main app  
**
    import { QueryClientProvider, QueryClient } from "react-query";
**
then; create new QueryClient
**
const queryClient = new QueryClient();

**
then; Wrap Element in <QueryClientProvider client={queryClient}>
**

const App=() => {
  return (
    <QueryClientProvider client={queryClient}>
      <Navbar />
      ... other components as required
    </QueryClientProvider>
  )
}

***** useRetrieve
usage:
import {useRetrieve} from '../customHooks/reactQuery/useRetrieve.jsx';

**
define const to be used. in this case people is the array that will be used, and URL is the API end point
the .env File in the project holds the server URL:=> REACT_APP_API_SERVER=http://localhost:5000 + <endPointTag> 
The example above uses 'people' as the <endPointTag> 
**

const url = `${process.env.REACT_APP_API_SERVER}/people`
const onSuccess => Optional if we want to do any actions after the fetching. i.e load a counter:
---> const onSuccess=(data) =>{dispatch({type:actions.FIELDS, fieldName: 'taskCount', payload:data.length})}
const {data:people, error, isLoading, isError} = useRetrieve("people",url, onSuccess);

****useDelete 
usage:
import {useDelete} from '../customHooks/reactQuery/useDelete';

.Then inside the Component since it's a hook.

const {isLoading:loadingDel, remove} = useDelete(props)
...same with props detail
const {isLoading:loadingDel, remove} = useDelete("tasks",url,onSuccess)

**** WIP define how to use the isLoading so that it reflect the effect only in the corresponding item...
**
props:
- "tasks" the given tag use in the react query in this case tasks...most match the one used in the useRetrieve 
for the same data.
- Url is the API end point. Make sure the url is included in the InitialState for the correponding <tag>Store
  => ...url: 'http://localhost:5000/tasks'
The function  will build the uri using the id that the function receives in the onClick event to trigger the 
deletion.
The example above uses 'people' as the <endPointTag> 
- onSuccess => Optional if we want to do any actions after the fetching. i.e nofify successful deletion
**
Return:
- isLoading renamed as loadingDel since isLoading probably will be used with the {useRetrieve} in the same component.
- remove the delete function that is inside the useDelete hook, it expects the id that most be passed in the onClick
event like-> onClick={()=>remove(<tagUsed>.id)}
- onSuccess: Optional a function to be executed after the deletion action was successful i.e a notification.
  as in the above example it could be more than 1 instruction.
**
example:
...
import {useDelete} from '../../customHooks/reactQuery/useDelete';
import { useTaskStore} from '../../context/tasks/TaskStore';
import { useGlobalDispatch} from '../../context/GlobalStore';


export default function ListTasks() {
  const {url} = useTaskStore();
  const onSuccessDel = ()=>{
    globalDispatch({type:actions.FIELDS, fieldName: 'notify', payload: {message:'Deleted Successfully',isOpen:true, type:'error'}});
    dispatch({type:actions.SET_COUNT, payload:-1});
  }
const {isLoading:loading, remove} = useDelete("people",url,onSuccessDel)
Return(
  ...
   <FaTimes style={{color:'red', cursor:'pointer'}} onClick={()=>remove(person.id)} />
   ...
)
}


****useUpdate 
usage:
import {useUpdate} from '../customHooks/reactQuery/useUpdate';

.Then inside the Component since it's a hook define const as below.

const {isLoading:loadingUpd, update} = useUpdate(props)
...same with props detail
const {isLoading:loadingUpd, update} = useUpdate("tasks",url,onSuccess)
**

.Then define a onFormSubmit function to be handled by react-hook-Form and include the update(data) function
  that is part of the useUpdate hook and receives the data coming from the react-hook-form

const OnFormSubmit = (data) => {
    update(data)
    ...
  }

props:
- "tasks" the given tag use in the react query in this case tasks...most match the one used in the useRetrieve 
for the same data.
- url is the API end point. Make sure the url is included in the InitialState for the correponding <tag>Store
  => ...url: 'http://localhost:5000/tasks'
The function  will build the uri using the <data.id> that the function receives in the onFormSubmit event to 
trigger the update.
- onSuccess => Optional if we want to do any actions after the fetching. i.e nofify successful update
**
Return:
- isLoading renamed as loadingUpd since isLoading probably will be used with the {useRetrieve} in the same component.
- update the update function that is inside the useUpdate hook, it expects the <data with id> that most be passed 
onFormSubmit event
- onSuccess: Optional a function to be executed after the update action was successful i.e a notification.
**
example:
...
import {useUpdate} from '../../customHooks/reactQuery/useUpdate';
import { useTaskStore} from '../../context/tasks/TaskStore';
import { useGlobalDispatch} from '../../context/GlobalStore';

export default function UpdateTask = () => {
  const {task,url} = useTaskStore();
  const globalDispatch=useGlobalDispatch();
  
  const onSuccessUpd = ()=>{
    globalDispatch({type:actions.FIELDS, fieldName: 'notify', payload:  {message:'Updated Successfully',isOpen:true, type:'success'}});
  }
  const {isLoading:loadingUpd, update} = useUpdate("tasks",url,onSuccessUpd)

  const OnFormSubmit = (data) => {
    update(data)
    history.push("/");
  }

  return (
    <TaskForm onFormSubmit={OnFormSubmit} defaultValues={task} isLoading={loadingUpd}/>
    // <TaskForm onFormSubmit={onFormSubmit}/>
  )
};


****useCreate

usage:
import {useCreate} from '../customHooks/reactQuery/useUpdate';

.Then inside the Component since it's a hook define const as below.

const {isLoading:loadingAdd, create} = useCreate(props)
...same with props detail
const {isLoading:loadingAdd, create} = useCreate("tasks",url,onSuccess)
**

.Then define a onFormSubmit function to be handled by react-hook-Form and include the create(data) function
  that is part of the useCreate hook and receives the data coming from the react-hook-form

const OnFormSubmit = (data) => {
    create(data)
    ...
  }

props:
- "tasks" the given tag use in the react query in this case tasks...most match the one used in the useRetrieve 
for the same data.
- url is the API end point. Make sure the url is included in the InitialState for the correponding <tag>Store
  => ...url: 'http://localhost:5000/tasks'
- onSuccess => Optional if we want to do any actions after the fetching. i.e nofify successful creation 
**
Return:
- isLoading renamed as loadingAdd since isLoading probably will be used with the {useRetrieve} in the same component.
- create the add function that is inside the useCreate hook, it expects the <data> that most be passed 
onFormSubmit event
- onSuccess: Optional a function to be executed after the create action was successful i.e a notification.
  as in the above example it could be more than 1 instruction.
**
example:
...
import {useCreate} from '../../customHooks/reactQuery/useCreate';
import { useTaskStore} from '../../context/tasks/TaskStore';
import { useGlobalDispatch} from '../../context/GlobalStore';

export default function AddTask = () => {
  const {url} = useTaskStore();
  const globalDispatch=useGlobalDispatch();
  
  const onSuccessAdd = ()=>{
    globalDispatch({type:actions.FIELDS, fieldName: 'notify', payload:  {message:'Added Successfully',isOpen:true, type:'success'}});
    dispatch({type:actions.SET_COUNT, payload:1});
  }
  const {isLoading:loadingAdd, create} = useCreate("tasks",url,onSuccessAdd)

  const OnFormSubmit = (data) => {
    create(data)
    history.push("/");
  }

  
  return (
    <TaskForm onFormSubmit={OnFormSubmit} defaultValues={initialState.task} isLoading={loadingAdd}/>
  )
};



